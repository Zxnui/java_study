# 设计模式

## UML 
Unified Modeling Language，设计软件蓝图和可视化建模语言，Rational Rose工具
- 类名
- 属性
- 操作
- 接口
- 类图
- 关系：依赖，关联，聚合，组合，泛化，实现

## 具体GoF 23类

| 范围/目的 | 创建型模式 | 结构型模式 | 行为型模式 |
| --------- | ---------- | ---------- | ---------- |
| 类模式  | 工厂方法 | 适配器-类 | 模板方法、解释器 |
| 对象模式 |  单例    |       代理  |      策略 |
|          |  原型    |      适配器-对象 | 命令 |
|          |   抽象工厂|      桥接       | 职责链 |
|          |  建造者  |      装饰        | 状态 |
|          |          |  外观         |  观察者 |
|          |          | 享元    |    中介者 |
|          |          | 组合    |    迭代器 |
|          |          |         | 访问者 |
|          |          |         | 备忘录 |
                                        
- 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。
- 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。
- 工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。
- 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
- 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。
- 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
- 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
- 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。
- 装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。
- 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
- 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。
- 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。
- 模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
- 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。
- 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。
- 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。
- 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。
- 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。
- 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。
- 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。
- 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。
- 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。
- 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。

## 开闭原则
软件实体应当对扩展开放，对修改关闭  

可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。  

因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了

## 里氏替换原则
继承必须确保超类所拥有的性质，在子类中仍然成立  

子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。

- 实现开闭原则重要方式之一
- 克服了继承中重写父类造成的可复用变差的缺点
- 动作正确性的保证，即类的扩展不会给已有的系统引入新的错误

## 依赖倒置原则
高层模块不应该依赖底层模块，两者都应该依赖其抽象。面向接口编程

- 每个类提供接口或抽象类，或者兼备
- 变量的声明类型尽量是接口或抽象类
- 任何类都不应该从具体类派生
- 使用继承时尽量遵循里氏替换原则

## 单一职责原则
一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分

该原则是为了：
- 一个职责变化可能会削弱或抑制该类其他职责能力
- 当客户端需要该对象一个职责时，不得不将其他职责包含进来，从而造成了冗余或代码浪费

单一职责同样也适用于方法。一个方法应该尽可能做好一件事情。如果一个方法处理的事情太多，其颗粒度会变得很粗，不利于重用

## 接口隔离原则
为各个类建立专用的接口，不要试图去建立庞大的接口供所有依赖它的类去调用

该原则是为了：
- 庞大的接口，分解为多个颗粒度小的接口，可以预防外来变更带来的扩散，提高系统的灵活和可维护性
- 接口隔离，提高系统内聚性，较少对外交互，降低耦合
- 接口大小定义合理，过小，接口过多，设计复杂，过大，灵活性降低，无法定制服务
- 多个接口，体现对象层次，通过接口的继承，实现对总接口的定义，也就是补充丰满
- 可以减少冗余，过大的接口通常放置很多不用的方法，当实现这个接口的时候，被迫设计冗余代码

实现：
- 接口尽量小，但是要有限度，一个接口只服务于一个子模块或业务逻辑
- 对依赖的接口，提供定制服务，只提供需要的方法，屏蔽不需要的方法，也就是控制好private public
- 根据业务具体情况。进行接口拆分，灵活使用，不要死板理解
- 提供内聚，减少对外交互，使用最小的对外方法，完成更多的事情，其实也是控制好private public

## 迪米特法则-最少知识原则
只和你直接接触的朋友交流，不和"陌生人"说话。如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。代理模式有所体现

迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。

该原则是为了：
- 降低类之间的耦合，提高模块相对独立性
- 低亲和度，提高类可复用率和系统扩展性

实现：
- 只依赖应该依赖的对象
- 只暴露应该暴露的方法

注意：
- 谨慎使用序列化
- 不要暴露类熟悉，使用get set方法
- 对其他类的引用上，引用对象次数降到最低
- 设计类时，优先考虑，将类设计为不变类
- 设计类时，降低类成员的访问权限
- 应该创建弱耦合类

## 合成复用原则
软件复用时，尽量使用组合和聚合来实现，其次考虑继承，继承严格遵循里氏替换原则

为了解决：
- 继承破坏了类的封装性，父类对子类是透明的，白箱复用
- 子类和父类高耦合
- 父类继承来的实现，编译时就定义了，无法改变，限制了复用灵活性

组合和聚合实现：
- 维持了类的封装性，黑箱复用
- 新旧类耦合低，新对象也是通过被引用的对象暴露的方法来引用的
- 这种复用是在运行时使用的。新对象可以动态引用和成分类型相同的对象

合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。